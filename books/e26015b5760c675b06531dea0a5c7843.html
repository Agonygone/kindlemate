<!DOCTYPE html>
<html>
	<head>
	<meta charset="utf-8" />
	<title> Kindle 读书笔记 </title>
	<meta name="viewport" content="width=device-width, initial-scale=1">
	<link href="../style/css/bootstrap.min.css" rel="stylesheet" type="text/css" />
	<link href="../style/css/bootstrap-theme.min.css" rel="stylesheet" type="text/css" />
	<link href="../style/css/custom.css" rel="stylesheet" type="text/css" />
</head>
<body>

	<div class="container">
		<header class="header col-md-12">
			<div class="page-header">
				<h1><small><span class="glyphicon glyphicon-book" aria-hidden="true"></span>Linux开源存储全栈详解从Ceph 到容器存储  [英特尔亚太研发有限公司]</small> <span class="badge"></span></h1>
			</div>
		</header>

        <div class="col-md-2">
			<ul class="nav nav-pills nav-stacked go-back">
				<li role="presentation" class="active text-center">
					<a href="../index.html" style="border-radius: 50%;"><span class="glyphicon glyphicon-backward" aria-hidden="true"></span></a>
				</li>
			</ul>
		</div>

    	<div class="col-md-12">
			<article>
				<div class="panel panel-default">
					<div class="panel-body mk88"><p>Linux内核收到系统调用的软中断，通过参数检查后，会调用虚拟文件系统（Virtual File System，VFS），虚拟文件系统会根据信息把相应的处理交给具体的文件系统，如ext2/3/4等文件系统，接着相应的文件I/O命令会转化成bio命令进入通用的块设备层，把针对文件的基于offset的读/写转化成基于逻辑区块地址（Logical Block Address，LBA）的读/写，并最终翻译成每个设备对应的可识别的地址，通过Linux的设备驱动对物理设备，如硬盘驱动器（Harddisk Drive，HDD）或固态硬盘进行相关的读/写。
                    </p></div>
					<div class="panel-footer text-right">
						<span class="label label-primary"><span class="glyphicon glyphicon-tag" aria-hidden="true"></span> 标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-bookmark" aria-hidden="true"></span>您在位置 #345-350的标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-time" aria-hidden="true"></span> 添加于 2021年11月6日星期六 下午10:50:41</span>
					</div>
				</div>
			</article>
        </div>

    	<div class="col-md-12">
			<article>
				<div class="panel panel-default">
					<div class="panel-body mk88"><p>我们知道支持OLTP的数据库对事务的支持有很强的要求，如那些没被正常提交的事务（Transaction）需要进行回滚。为了满足这一需求，数据库引入WAL（Write Ahead Log）机制，即任何写磁盘操作必须先写日志。
                    </p></div>
					<div class="panel-footer text-right">
						<span class="label label-primary"><span class="glyphicon glyphicon-tag" aria-hidden="true"></span> 标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-bookmark" aria-hidden="true"></span>您在位置 #645-647的标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-time" aria-hidden="true"></span> 添加于 2021年11月7日星期日 上午8:14:06</span>
					</div>
				</div>
			</article>
        </div>

    	<div class="col-md-12">
			<article>
				<div class="panel panel-default">
					<div class="panel-body mk88"><p>Die/LUN是接收和执行Flash命令的基本单元，不同的Die可以同时接收和执行不同的命令，但在一个Die中一次只能执行一个命令，不能对其中的某个页在写的同时又对其他页进行读访问。
                    </p></div>
					<div class="panel-footer text-right">
						<span class="label label-primary"><span class="glyphicon glyphicon-tag" aria-hidden="true"></span> 标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-bookmark" aria-hidden="true"></span>您在位置 #1174-1176的标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-time" aria-hidden="true"></span> 添加于 2021年11月7日星期日 上午10:34:42</span>
					</div>
				</div>
			</article>
        </div>

    	<div class="col-md-12">
			<article>
				<div class="panel panel-default">
					<div class="panel-body mk88"><p>每次NAND制程的升级都能将NAND存储密度提升到一个新的高度，但是NAND闪存的制程工艺是一把双刃剑，容量提升、成本降低的同时可靠性及性能都在下降，因为工艺越先进，NAND的氧化层越薄，可靠性也越差，厂商就需要采取额外的手段来弥补，但这又会提高成本，以至于达到某个点之后制程工艺已经无法带来优势了。
                    </p></div>
					<div class="panel-footer text-right">
						<span class="label label-primary"><span class="glyphicon glyphicon-tag" aria-hidden="true"></span> 标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-bookmark" aria-hidden="true"></span>您在位置 #1180-1184的标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-time" aria-hidden="true"></span> 添加于 2021年11月7日星期日 上午10:35:25</span>
					</div>
				</div>
			</article>
        </div>

    	<div class="col-md-12">
			<article>
				<div class="panel panel-default">
					<div class="panel-body mk88"><p>在3D XPoint中，内存单元和选择器被存储总线交叉叠加在一起，每一层的总线又会被导线连接。这又该怎么理解呢？按原来的方式，内存单元之间访问就像两个住在楼梯房的好朋友，每次去其中一家串门都需要走过道爬楼梯。而3D XPoint则是相当于为他们设置了一个直达电梯，每次串门“叮”的一声就到了。这样一来，数据访问效率就会高很多。
                    </p></div>
					<div class="panel-footer text-right">
						<span class="label label-primary"><span class="glyphicon glyphicon-tag" aria-hidden="true"></span> 标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-bookmark" aria-hidden="true"></span>您在位置 #1235-1238的标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-time" aria-hidden="true"></span> 添加于 2021年11月7日星期日 上午10:38:29</span>
					</div>
				</div>
			</article>
        </div>

    	<div class="col-md-12">
			<article>
				<div class="panel panel-default">
					<div class="panel-body mk88"><p>NVMe或称NVMHCIS（Non-Volatile Memory Host Controller Interface Specification，非易失性存储主机控制器接口标准）最早是由英特尔公司于2007年提出的。英特尔公司领衔成立了NVMHCIS工作组，成员包括三星、美光等公司，致力于使将来的存储产品从AHCI中解放出来。
                    </p></div>
					<div class="panel-footer text-right">
						<span class="label label-primary"><span class="glyphicon glyphicon-tag" aria-hidden="true"></span> 标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-bookmark" aria-hidden="true"></span>您在位置 #1274-1276的标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-time" aria-hidden="true"></span> 添加于 2021年11月7日星期日 上午10:41:44</span>
					</div>
				</div>
			</article>
        </div>

    	<div class="col-md-12">
			<article>
				<div class="panel panel-default">
					<div class="panel-body mk88"><p>关于NVMe-oF，目前有两种类型的传输正在开发，使用RDMA的NVMe-oF和使用FC-NVMe的NVMe-oF。这里的RDMA包括了InfiniBand、RoCE（RDMA over Converged Ethernet）和iWARP（internet Wide Area RDMA Protocol），RDMA支持在不涉及处理器的情况下将数据传输到两台计算机的内存，并提供低延迟和快速的数据传输。从逻辑架构上看，与NVMe over PCIe相比，NVMe over RDMA在软件开销上的增加很小，可以近似地认为跨网络访问和本地访问的延迟几乎是一样的。
                    </p></div>
					<div class="panel-footer text-right">
						<span class="label label-primary"><span class="glyphicon glyphicon-tag" aria-hidden="true"></span> 标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-bookmark" aria-hidden="true"></span>您在位置 #1304-1308的标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-time" aria-hidden="true"></span> 添加于 2021年11月7日星期日 下午12:56:57</span>
					</div>
				</div>
			</article>
        </div>

    	<div class="col-md-12">
			<article>
				<div class="panel panel-default">
					<div class="panel-body mk88"><p>宽泛一点来说，Linux存储系统包括两个部分：第一部分是站在用户的角度提供读/写的接口，数据以流为表现形式；第二部分是站在存储设备的角度提供读/写接口，数据以块为表现形式。文件系统位于两者中间起到承上启下的作用。
                    </p></div>
					<div class="panel-footer text-right">
						<span class="label label-primary"><span class="glyphicon glyphicon-tag" aria-hidden="true"></span> 标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-bookmark" aria-hidden="true"></span>您在位置 #1371-1373的标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-time" aria-hidden="true"></span> 添加于 2021年11月7日星期日 下午1:01:28</span>
					</div>
				</div>
			</article>
        </div>

    	<div class="col-md-12">
			<article>
				<div class="panel panel-default">
					<div class="panel-body mk88"><p>Direct I/O最主要的优点就是通过减少内核缓冲区和用户空间的数据复制次数，降低文件读/写时所带来的CPU负载能力及内存带宽的占用率。如果传输的数据量很大，使用Direct I/O的方式将会大大提高性能。然而，不经过内核缓冲区直接进行磁盘的读/写，必然会引起阻塞，因此通常Direct I/O与AIO（异步I/O）一起使用。
                    </p></div>
					<div class="panel-footer text-right">
						<span class="label label-primary"><span class="glyphicon glyphicon-tag" aria-hidden="true"></span> 标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-bookmark" aria-hidden="true"></span>您在位置 #1634-1637的标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-time" aria-hidden="true"></span> 添加于 2021年11月7日星期日 下午8:28:48</span>
					</div>
				</div>
			</article>
        </div>

    	<div class="col-md-12">
			<article>
				<div class="panel panel-default">
					<div class="panel-body mk88"><p>超线程技术（Hyperthreading）是指操作系统将每个物理核识别为两个可以并行工作的逻辑核，它们有自己独立的寄存器，但是共用主要的执行单元。这得益于超标量（Superscaler）技术，软件可以通过CPU同时分发多条指令到空闲的执行单元，最大限度地利用CPU的计算资源。
                    </p></div>
					<div class="panel-footer text-right">
						<span class="label label-primary"><span class="glyphicon glyphicon-tag" aria-hidden="true"></span> 标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-bookmark" aria-hidden="true"></span>您在位置 #1878-1881的标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-time" aria-hidden="true"></span> 添加于 2021年11月7日星期日 下午8:49:01</span>
					</div>
				</div>
			</article>
        </div>

    	<div class="col-md-12">
			<article>
				<div class="panel panel-default">
					<div class="panel-body mk88"><p>如前所述，virtio后端设备用于具体响应Guest的命令请求。例如，对virtio-scsi设备来讲，该virtio后端负责SCSI命令的响应，QEMU负责模拟该PCI设备，把该SCSI命令响应的模块在QEMU进程之外实现的方案称为vhost。这里同样分为两种实现方式，在Linux内核中实现的叫作vhost-kernel，而在用户态实现的叫作vhost-user。
                    </p></div>
					<div class="panel-footer text-right">
						<span class="label label-primary"><span class="glyphicon glyphicon-tag" aria-hidden="true"></span> 标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-bookmark" aria-hidden="true"></span>您在位置 #2715-2718的标注</span>
						<span class="label label-default"><span class="glyphicon glyphicon-time" aria-hidden="true"></span> 添加于 2021年11月7日星期日 下午11:16:33</span>
					</div>
				</div>
			</article>
        </div>

        </div>
    </div>
</body>
</html>
